#!/usr/bin/env python
"""
Generates a fail response to XQueue for queued submissions.

"""
import argparse
import json
import logging
import os
import sys

from pprint import pprint

import pika

from bux_grader_framework import Grader
from bux_grader_framework.queues import eval_queue_name

FAIL_RESPONSE = {
    "score": 0.0,
    "correct": False,
    "msg": "<div><p>The external grader is unable to process your submission at this time. Please review your submission for errors and try again later.</p></div>"
}


def prompt_to_delete():
    return True if raw_input("Fail submission? [y/N] ").lower() == "y" else False


def fail_pending_submissions(xqueue, queue, force=False, username='guest',
                             password='guest', host='localhost', port=5672,
                             virtual_host='/'):
    """ Fail pending submissions in the given queue.

    The function will print each submission and prompt to continue.

    """

    # Establish a blocking connection
    credentials = pika.PlainCredentials(username,
                                        password)
    params = pika.ConnectionParameters(host=host,
                                       port=port,
                                       virtual_host=virtual_host,
                                       credentials=credentials)

    connection = pika.BlockingConnection(params)
    channel = connection.channel()

    # Issue a passive queue declare to get a message count.
    print "Checking evaluator queue: %s" % queue
    method_frame = channel.queue_declare(queue, passive=True)
    message_count = method_frame.method.message_count

    requeue_tags = []
    ack_tags = []

    if message_count:
        print "Found %d pending submissions..." % message_count

        # Re-publish each dead lettered message to the original queue.
        for num in range(message_count):
            method, props, body = channel.basic_get(queue=queue)
            frame = json.loads(body)
            submission = frame["submission"]

            print "Failing Submission:\n"
            pprint(submission)
            print

            delete = force or prompt_to_delete()
            if delete:
                print "Issuing failure response to submission #%d: \n" % submission["xqueue_header"]["submission_id"]
                pprint(FAIL_RESPONSE)
                if xqueue.put_result(submission, FAIL_RESPONSE):
                    ack_tags.append(method.delivery_tag)
                else:
                    requeue_tags.append(method.delivery_tag)
            else:
                print "Skipping..."
            print
    else:
        print "No pending submissions found."

    # Acknowledge submissions that we failed.
    for tag in ack_tags:
        channel.basic_ack(tag)

    # Requeue submissions that we didn't.
    for tag in requeue_tags:
        channel.basic_nack(tag, requeue=True)

    channel.close()
    connection.close()


if __name__ == "__main__":
    logging.basicConfig(level=logging.WARNING)

    parser = argparse.ArgumentParser(description='Generates a fail response to XQueue for queued submissions.')
    parser.add_argument('--settings', dest='settings',
                        help='Grader settings module path')
    parser.add_argument('--pythonpath', dest='pythonpath',
                        help='Path to add to sys.path')
    parser.add_argument('-f', '--force', dest='force', action='store_true',
                        help='Do not prompt - fail all submissions')
    args = parser.parse_args()

    # Add current directory to the path
    print "Adding curent directory to sys.path: {}".format(os.getcwd())
    sys.path.insert(0, os.getcwd())

    # Insert extra path components to pythonpath if passed
    if args.pythonpath:
        print "Adding to sys.path: {}".format(args.pythonpath)
        sys.path.insert(0, args.pythonpath)

    # Set grader settings module from command line
    if args.settings:
        settings = args.settings
    else:
        settings = os.environ.get('GRADER_SETTINGS_MODULE', '')
    print "Settings module: {}".format(settings)
    print "Force mode: %s" % args.force
    print

    # Create and configure the grader from the provided settings module
    grader = Grader()
    grader.config_from_module(settings)

    # Extract RabbitMQ credentials
    creds = {}
    try:
        creds['username'] = grader.config['RABBITMQ_USER']
        creds['password'] = grader.config['RABBITMQ_PASSWORD']
        creds['host'] = grader.config['RABBITMQ_HOST']
        creds['port'] = grader.config['RABBITMQ_PORT']
        creds['virtual_host'] = grader.config['RABBITMQ_VHOST']
    except KeyError as e:
        sys.exit("Could not connect to RabbitMQ")

    # Check each evaluator queue for pending submissions
    for evaluator in grader.evaluators:
        fail_pending_submissions(grader.xqueue(), eval_queue_name(evaluator), args.force, **creds)
